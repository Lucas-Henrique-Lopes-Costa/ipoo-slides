---
title: IPOO - Cap. 4 Agrupando Objetos
subtitle: Aula 4.1 - Teórica
---

## {.smaller}

Algumas perguntas **para refletir** antes de começar a aula:

- Quantas **anotações** vocês fez no caderno ao estudar os três primeiros capítulos da disciplina?
- Você estudou **todo o conteúdo** de todas as aulas teóricas ANP anteriores?
- Você **leu** alguma parte do **livro** da disciplina?

. . .

:::: {.columns}

::: {.column width="30%"}

![](imagens/meme_pense_sobre_isso.jpg)

:::

::: {.column width="70%"}
**Lembre-se** que [você precisa ser a pessoa mais interessada no seu próprio sucesso!]{.alert}
:::

::::

## Principais Conceitos do Capítulo {.smaller}

::: {.nonincremental}
- Coleções
- Laços (*loops*)
- Iteradores
- Vetores (*arrays*)
:::

. . .

Construções Java do capítulo

::: {.nonincremental}
- `ArrayList`, `Iterator`, *for-each*, `while`, `null`, objetos anônimos, vetor, `++`.
:::

## {.smaller}

O principal objetivo deste capítulo é mostrar algumas formas que temos de **agrupar objetos** em [coleções]{.alert}.

- Nesta aula vamos aprender sobre a classe `ArrayList`, que é um exempo de coleção de tamanho flexível.
- Na aula seguinte, veremos como usar vetores em Java.

. . .

Ao usar coleções, precisamos percorrer (ou iterar) sobre seus elementos.

- Para isso, utilizaremos estruturas de repetição: *for-each*, `while` e `for`.

. . .

Este capítulo tem mais conteúdo que os anteriores.

- E, portanto, demandará maior dedicação e esforço.
- Mas os conceitos aqui são fundamentais para que se torne um bom programador.
- E para que entenda os conceitos dos capítulos seguintes.

# Usando os conceitos do Cap. 3 como base {background-color="#40666e"}

## {.smaller}

Além de conhecermos os novos conceitos de [coleção]{.alert} e [iteradores]{.alert},

- vamos revisitar os conceitos de [abstração]{.alert} e [interação entre objetos]{.alert} vistos anteriormente.

. . .

Vimos que abstração nos permite simplificar um problema:

- identificando componentes como unidades completas, sem nos preocuparmos com seus detalhes.

. . .

Veremos esse princípio, na prática, ao utilizarmos uma classe da [Biblioteca de Classes]{.alert} do Java.

- Ao implementar um programa, um bom desenvolvedor deve sempre procurar por classes disponíveis na biblioteca de classes da linguagem.
- Com isso, evitamos *"reinventar a roda"*, evitando retrabalho com coisas que já estão prontas e testadas.
- E, assim, podemos focar no que é a essência do problema que queremos resolver.

## {.smaller}

Portanto, **vale muito a pena**, se familizarizar com as classes mais comuns da biblioteca do Java.

- O poder da [abstração]{.alert} nos permite usar essas classes sem precisarmos saber praticamente nada sobre como essas classes são implementadas internamente.

. . .

Usar essas classes se refere basicamente a:

- **Criar objetos** delas e **chamar os métodos** desses objetos.
- Portanto, teremos uma [interação entre os nossos objetos e os objetos das classes]{.alert} da biblioteca.

## {.smaller}

Como foi citado no início da disciplina, esse material tem uma **abordagem iterativa**.

- O que significa que os conceitos são revisitados o tempo todo,
- com o objetivo de aprofundarmos nosso entendimento sobre eles.

. . .

Neste capítulo veremos também que [abstação]{.alert} não se refere apenas a ignorar detalhes.

- Mas também a identificar padrões que aparecem repetidamente no código.
- O que nos permite reutilizar em uma nova situação métodos e classes que já havíamos implementado e usado antes.


# A abstração de coleção {background-color="#40666e"}

## {.smaller}

O que é uma [coleção]{.alert}?

- Segundo o dicionário Priberam, um dos significados é: 
  
  *"Reunião de  objetos da mesma natureza."*

. . .

Uma coleção pode ser:

- Grande.
  - Ex.: todos os alunos da universidade.
- Pequena.
  - Ex.: as disciplinas que um aluno está matriculado em um semestre.
- Ou até mesmo vazia.
  - Ex.: os prêmios Nobel que eu já ganhei.

## {.smaller}

Se você tem uma coleção de alguma coisa (moedas, autógrafos, o que seja),

- há algumas [operações]{.alert} que você pode fazer com a sua coleção de tempos em tempos, como por ex.:
  - [Adicionar]{.alert} um novo item à coleção.
  - [Remover]{.alert} um item da coleção (por ter vendido, ou ser repetido, por ex.).
  - [Organizar]{.alert} os itens de alguma forma (por tamanho ou valor, por ex.).
  - [Listar um subconjunto]{.alert} dos itens para algum propósito (moedas do império romano, por ex.).

. . .

Repare que essas são **operações comuns** em uma coleção.

- Independente dos objetos que ela guarda.

## {.smaller}

No contexto de POO, uma **coleção** pode ser **representada por uma** [classe]{.alert}. 

- E as **operações** sobre a coleção por [métodos]{.alert} desta classe.
- Uma **coleção particular** (minha coleção de músicas, por ex.) seria uma [instância da classe]{.alert}, ou seja, um objeto da classe.
  - Note que os **itens** da coleção (as moedas, por ex.) seriam objetos **de outra classe**.

. . .

Alguns exemplos de coleção comuns no contexto de programação seriam:

- O conjunto de estudantes da universidade no SIG:
  - A cada semestre novos estudantes são adicionados, e alunos formados são removidos.
- Filmes e séries no catálogo da Netflix:
  - O catálogo é continuamente atualizado, acrescentando novos filmes e retirando outros.
- Os comentários de uma publicação em uma rede social:
  - Novos comentários são postados e comentários também podem ser removidos.

## {.smaller}

Veja que a quantidade de itens armazenada em uma coleção pode variar com o tempo.

- Uma solução ingênua para tratar isso em um código Java seria criar um atributo para cada objeto da coleção.
- Mas veja que precisaríamos adivinhar quantos objetos a coleção precisaria.
- Ou acabar declarando vários atributos que não seriam usados.

. . .

Portanto, é muito mais prático se não precisarmos saber, antecipadamente, quantos objetos a coleção precisará ter.

- Para isso, vamos utilizar a forma mais simples possível de agrupar objetos em Java: a classe `ArrayList`.
- Vamos usar como exemplo um projeto que nos permite organizar uma playlist de músicas.

. . .

::: {.callout-tip title="Conceito" icon=false}
Um objeto **coleção** pode guardar um número arbitário de outros objetos.
:::

# Um organizador de *playlist* de músicas {background-color="#40666e"}

## {.smaller}

Vamos criar uma classe para nos ajudar a organizar arquivos de músicas guardados no computador.

- Nossa classe não vai guardar os detalhes das músicas.
- Em vez disso, vamos usar a classe `ArrayList` da biblioteca de classes para nos poupar trabalho.

. . .

:::: {.columns}

::: {.column width="30%"}

![](imagens/duvida_para_que_classe_ArrayList.png)

:::

::: {.column width="70%"}
- A questão é que as classes da biblioteca de classes foram criadas para uso geral.
- E não para necessidades específicas.
- Um ArrayList pode ser usado para guardar dados de estudantes, ou de lembretes de eventos.
- A nossa classe específica é que precisará tratar de operações específicas relacionadas a arquivos de músicas.
:::

::::

## {.smaller}

Por razões didáticas, ou seja, para ficar mais fácil assimilarmos os conceitos:

- vamos começar com uma versão bem simples da classe,
- que lida apenas com os nomes dos arquivos de música.
  - Sem detalhes como título, artista, duração, etc.

. . .

Nesse cenário, precisaremos que o ArrayList guarde objetos String que representem os nomes dos arquivos.

- A ideia é começar simples, para focarmos no conceito que vamos aprender agora, criação e uso de coleções.
- Depois vamos incrementar um projeto para que ele pareça com um organizar e tocador de músicas de verdade.

## {.smaller}

A classe vai assumir que cada arquivo tem uma única música.

- E o nome do arquivo tem o nome do artista e da música (usaremos isso mais adiante).

. . .

As **operações** básicas que queremos na primeira versão da classe são:

- Adicionar músicas na coleção.
- A coleção não deve ter limite de tamanho, exceto a memória do computador.
- Retornar a quantidade de músicas na coleção.
- Listar todas as músicas.

. . .

Veremos que a classe `ArrayList` torna bem fácil tratar essas operações.

## {.smaller}

Estamos adotando uma **abordagem incremental**.

- Começamos com uma **versão básica** que mostra como criar e usar um ArrayList.
- E depois vamos melhorá-la até chegar ao ponto de nosso programar **tocar a música de verdade**.

. . .

:::: {.columns}

::: {.column width="30%"}

![](imagens/fica_a_dica.png)

:::

::: {.column width="70%"}
Lembre-se que adotar uma abordagem incremental tem uma probabilidade de sucesso muito maior do que querer implementar tudo de uma vez.
:::

::::

##

::: {.callout-note title="Exercício" icon=false}
Antes de analisarmos o código-fonte, vamos entender o funcionamento do organizador de músicas.

Abra o probjeto [organizador-musicas-v1](https://github.com/ufla-ipoo/organizador-musicas-v1) no BlueJ e crie um objeto `OrganizadorDeMusicas`.
Guarde nomes de alguns arquivos de música nele (são simplesmente strings).
Como não vamos tocar as músicas nesse ponto, qualquer nome de arquivo serve, mas há um repositório com [arquivos de músicas](https://github.com/ufla-ipoo/amostra-musicas) de verdade que você pode querer baixar e usar.

Confira se o número de arquivos retornado pelo método `obterQuantidadeDeArquivos` bate com a quantidade que você armazenou.
Ao usar o método `listarArquivo` você deve notar que você precisa passar o valor zero para imprimir o primeiro nome de arquivo, um para o segundo, e assim por diante.
Você imagina, por que?
:::

##

::: {.callout-note title="Exercício" icon=false}
O que acontece se você criar um objeto `OrganizadorDeMusicas` e chamar `removerArquivo(0)` antes de ter adicionado qualquer música?

Ocorre algum erro? Você esperava que ocorresse algum erro?
:::

::: {.callout-note title="Exercício" icon=false}
Crie um `OrganizadorDeMusicas` e adicione dois nomes de arquivos a ele.
Chame `listarArquivo(0)` e `listarArquivo(1)` para mostrar os dois arquivos.
Agora chame `removerArquivo(0)` e depois `listarArquivo(0)`.

O que aconteceu? Era o que você esperava?

Você imagina alguma explicação para o que deve ter acontecido quando você removeu o primeiro arquivo da coleção?
:::


# Usando uma classe da biblioteca {background-color="#40666e"}

Leia o código da classe `OrganizadorDeMusicas`.

- Repare que ela usa a classe `ArrayList`.
- Mas a classe `ArrayList` não aparece no diagrama de classes do BlueJ.

. . .

::: {.callout-note title="Bibliotecas de classes" appearance="simple" icon=false}
Uma das coisas que torna as linguagens OO (Orientadas a Objetos) poderosas, é que elas geralmente trazem junto bibliotecas de classes.

- Essas bibliotecas geralmente têm centenas ou milhares de classes que são muito úteis para os desenvolvedores em diversos projetos.
- Java chama essas bibliotecas de [pacotes]{.alert}.
- Nós usamos as classes das bibliotecas exatamente do mesmo jeito que usamos nossas próprias classes.
- Criamos objetos usando `new`, e as classes têm atributos, construtores e métodos.
:::

## Importando uma classe da biblioteca {.smaller}

A primeira linha da classe `OrganizadorDeMusicas` mostra como acessar uma classe de biblioteca em Java.

```{.java code-line-numbers="false"}
  import java.util.ArrayList;
```

. . .

Este comando disponibiliza a classe `ArrayList` do pacote `java.util` para ser usada em nossa classe.

- Com isso, nós podemos então usar a classe `ArrayList` como se fosse uma classe do nosso projeto.
- Nós usamos então para declarar o atributo `arquivos`.
  ```{.java code-line-numbers="false"}
    private ArrayList<String> arquivos;
  ```

## {.smaller}

Repare que a declaração do atributo `arquivos` traz algo de diferente: `<String>`

- Isso é necessário porque, como vimos antes, a classe `ArrayList` foi criada para uso geral.
  - Ou seja, ela não restringe que objetos ela guarda.
- Mas, quando criamos um objeto `ArrayList`, precisamos dizer qual o tipo dos objetos que serão guardados nele.
- Classes que são parametrizadas com um segundo tipo (como a `ArrayList`) são chamadas [classes genéricas]{.alert} em Java.
  - Veremos mais sobre isso mais adiante.

. . .

Portanto, sempre que usamos uma coleção precisamos especificar dois tipos:

- O tipo da coleção em si (nesse caso, `ArrayList`).
- E o tipo dos elementos que queremos guardar na coleção (nesse caso, `String`).
- Assim, uma declaração `ArrayList<String>` costuma ser lida como *ArrayList de strings*.

## Notação diamante {.smaller}

Da mesma forma vimos antes que o construor da classe `VisorDeRelogio` criava objetos da classe `VisorDeNumero`,

- a classe `OrganizadorDeMusicas` cria um objeto do tipo `ArrayList` e o guarda no atributo `arquivos`.

Fazemos isso com o comando:

```{.java code-line-numbers="false"}
  arquivos = new ArrayList<>();
```

- Nós chamamos essa sintaxe de **notação diamante** (por causa do sinais `<>` consecutivos).
- Repare que poderíamos escrever `new ArrayList<String>()`
  - Mas podemos omitir o tipo dos objetos, porque o compilador usa a declaração da variável `arquivos` para saber qual tipo deve ser usado.
- Portanto, usar `<>` é só um atalho para escrever código mais rápido.

## Principais métodos da classe `ArrayList` {.smaller}

A classe `ArrayList` possui muitos métodos, mas, por enquanto, usaremos apenas quatro:

- `add`: adiciona um elmento ao final da lista.
- `size`: retorna a quantidade de elementos na coleção.
- `get` e `remove`: veremos mais adiante, mas já dá para ter uma ideia vendo como são utilizados no código.

# Estruturas de objetos com coleções {background-color="#40666e"}

## {.smaller auto-animate=true}

Para entendermos como uma coleção como a ArrayList funciona, é interessante analisarmos um diagrama de objetos.

- Compare a figura abaixo que mostra um `OrganizadorDeMusicas` com duas strings de nomes de arquivos, com a próxima que mostra com três.

. . .

![](imagens/organizador_musicas_diagrama_objetos.png)

## {.smaller auto-animate=true}

::: {.nonincremental}

Para entendermos como uma coleção como a ArrayList funciona, é interessante analisarmos um diagrama de objetos.

- Compare a figura abaixo que mostra um `OrganizadorDeMusicas` com duas strings de nomes de arquivos, com a próxima que mostra com três.

:::

![](imagens/organizador_musicas_diagrama_objetos2.png)

## {.smaller}

Há três características importantes sobre o `ArrayList` que precisamos saber:

- Podemos aumentar sua capacidade conforme a necessidade.
- Ele mantém uma contagem privada da quantidade de itens armazenados (e o método `size` retorna essa informação).
- Ele mantém a ordem dos elementos inseridos (e podemos obter os objetos na mesma ordem).



##

::: {.callout-note title="Exercício" icon=false}
:::